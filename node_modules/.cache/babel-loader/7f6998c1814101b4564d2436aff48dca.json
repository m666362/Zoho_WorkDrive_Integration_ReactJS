{"ast":null,"code":"import { useRef, useEffect, useDebugValue, useReducer, useCallback, useMemo, createContext as createContext$1, useContext as useContext$1, createElement, forwardRef, memo as memo$1 } from 'react';\nimport { createContext, useContext, useContextUpdate, useContextSelector } from 'use-context-selector';\nimport { affectedToPathList, isChanged, createProxy, trackMemo } from 'proxy-compare';\nexport { getUntracked as getUntrackedObject } from 'proxy-compare';\n\nconst useAffectedDebugValue = (state, affected) => {\n  const pathList = useRef();\n  useEffect(() => {\n    pathList.current = affectedToPathList(state, affected);\n  });\n  useDebugValue(state);\n};\n\nconst createTrackedSelector = useSelector => {\n  const useTrackedSelector = () => {\n    const [, forceUpdate] = useReducer(c => c + 1, 0);\n    const affected = new WeakMap();\n    const lastAffected = useRef();\n    const prevState = useRef();\n    const lastState = useRef();\n    useEffect(() => {\n      lastAffected.current = affected;\n\n      if (prevState.current !== lastState.current && isChanged(prevState.current, lastState.current, affected, new WeakMap())) {\n        prevState.current = lastState.current;\n        forceUpdate();\n      }\n    });\n    const selector = useCallback(nextState => {\n      lastState.current = nextState;\n\n      if (prevState.current && prevState.current !== nextState && lastAffected.current && !isChanged(prevState.current, nextState, lastAffected.current, new WeakMap())) {\n        // not changed\n        return prevState.current;\n      }\n\n      prevState.current = nextState;\n      return nextState;\n    }, []);\n    const state = useSelector(selector);\n\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      useAffectedDebugValue(state, affected);\n    }\n\n    const proxyCache = useMemo(() => new WeakMap(), []); // per-hook proxyCache\n\n    return createProxy(state, affected, proxyCache);\n  };\n\n  return useTrackedSelector;\n};\n/* eslint react/destructuring-assignment: off */\n\n\nconst createContainer = (useValue, options) => {\n  if (typeof options === 'boolean') {\n    // eslint-disable-next-line no-console\n    console.warn('boolean option is deprecated, please specify { concurrentMode: true }');\n    options = {\n      concurrentMode: options\n    };\n  }\n\n  const {\n    stateContextName = 'StateContainer',\n    updateContextName = 'UpdateContainer',\n    concurrentMode\n  } = options || {};\n  const StateContext = createContext(null);\n  const UpdateContext = createContext$1(null);\n  StateContext.displayName = stateContextName;\n  UpdateContext.displayName = updateContextName;\n\n  const Provider = props => {\n    const [state, update] = useValue(props);\n    return createElement(UpdateContext.Provider, {\n      value: update\n    }, createElement(StateContext.Provider, {\n      value: state\n    }, props.children));\n  };\n\n  const useSelector = selector => {\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production' // eslint-disable-next-line react-hooks/rules-of-hooks\n    && useContext(StateContext) === null) {\n      throw new Error('Please use <Provider>');\n    }\n\n    const selected = useContextSelector(StateContext, selector);\n    useDebugValue(selected);\n    return selected;\n  };\n\n  const useTrackedState = createTrackedSelector(useSelector);\n  const useUpdate = concurrentMode ? () => {\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && (useContext(StateContext) === null || useContext$1(UpdateContext) === null)) {\n      throw new Error('Please use <Provider>');\n    }\n\n    const contextUpdate = useContextUpdate(StateContext);\n    const update = useContext$1(UpdateContext);\n    return useCallback(function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      let result;\n      contextUpdate(() => {\n        result = update(...args);\n      });\n      return result;\n    }, [contextUpdate, update]);\n  } // not concurrentMode\n  : () => {\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && useContext$1(UpdateContext) === null) {\n      throw new Error('Please use <Provider>');\n    }\n\n    return useContext$1(UpdateContext);\n  };\n\n  const useTracked = () => [useTrackedState(), useUpdate()];\n\n  return {\n    Provider,\n    useTrackedState,\n    useTracked,\n    useUpdate,\n    useSelector\n  };\n};\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction memo(Component, propsAreEqual) {\n  const WrappedComponent = forwardRef((props, ref) => {\n    Object.values(props).forEach(trackMemo);\n    return createElement(Component, _extends({}, props, {\n      ref\n    }));\n  });\n  return memo$1(WrappedComponent, propsAreEqual);\n}\n\nexport { createContainer, createTrackedSelector, memo };","map":{"version":3,"sources":["../src/utils.ts","../src/createTrackedSelector.ts","../src/createContainer.ts","../src/memo.ts"],"names":["useAffectedDebugValue","pathList","useRef","useEffect","affectedToPathList","useDebugValue","createTrackedSelector","useSelector","useTrackedSelector","useReducer","c","affected","lastAffected","prevState","lastState","isChanged","forceUpdate","selector","useCallback","nextState","state","process","proxyCache","useMemo","createProxy","createContainer","console","options","concurrentMode","stateContextName","updateContextName","StateContext","createContext","UpdateContext","createContextOrig","Provider","props","useValue","createElement","value","update","useContext","selected","useContextSelector","useTrackedState","useUpdate","useContextOrig","contextUpdate","useContextUpdate","result","useTracked","WrappedComponent","forwardRef","Object","ref","reactMemo"],"mappings":"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","sourcesContent":["import { useEffect, useRef, useDebugValue } from 'react';\nimport { affectedToPathList } from 'proxy-compare';\n\ntype Obj = Record<string, unknown>;\n\nexport const useAffectedDebugValue = <State>(\n  state: State,\n  affected: WeakMap<Obj, unknown>,\n) => {\n  const pathList = useRef<(string | number | symbol)[][]>();\n  useEffect(() => {\n    pathList.current = affectedToPathList(state, affected);\n  });\n  useDebugValue(state);\n};\n","import {\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n} from 'react';\nimport { createProxy, isChanged } from 'proxy-compare';\n\nimport { useAffectedDebugValue } from './utils';\n\nexport const createTrackedSelector = <State>(\n  useSelector: <Selected>(selector: (state: State) => Selected) => Selected,\n) => {\n  const useTrackedSelector = () => {\n    const [, forceUpdate] = useReducer((c) => c + 1, 0);\n    const affected = new WeakMap();\n    const lastAffected = useRef<typeof affected>();\n    const prevState = useRef<State>();\n    const lastState = useRef<State>();\n    useEffect(() => {\n      lastAffected.current = affected;\n      if (prevState.current !== lastState.current\n        && isChanged(\n          prevState.current,\n          lastState.current,\n          affected,\n          new WeakMap(),\n        )) {\n        prevState.current = lastState.current;\n        forceUpdate();\n      }\n    });\n    const selector = useCallback((nextState: State) => {\n      lastState.current = nextState;\n      if (prevState.current\n        && prevState.current !== nextState\n        && lastAffected.current\n        && !isChanged(\n          prevState.current,\n          nextState,\n          lastAffected.current,\n          new WeakMap(),\n        )\n      ) {\n        // not changed\n        return prevState.current;\n      }\n      prevState.current = nextState;\n      return nextState;\n    }, []);\n    const state = useSelector(selector);\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      useAffectedDebugValue(state, affected);\n    }\n    const proxyCache = useMemo(() => new WeakMap(), []); // per-hook proxyCache\n    return createProxy(state, affected, proxyCache);\n  };\n  return useTrackedSelector;\n};\n","/* eslint react/destructuring-assignment: off */\n\nimport {\n  Context as ContextOrig,\n  FC,\n  createContext as createContextOrig,\n  createElement,\n  useCallback,\n  useContext as useContextOrig,\n  useDebugValue,\n} from 'react';\n\nimport {\n  Context,\n  createContext,\n  useContext,\n  useContextSelector,\n  useContextUpdate,\n} from 'use-context-selector';\n\nimport { createTrackedSelector } from './createTrackedSelector';\n\ntype AnyFunction = (...args: any[]) => any;\ntype Options = {\n  stateContextName?: string;\n  updateContextName?: string;\n  concurrentMode?: boolean;\n}\n/**\n * [Deprecated] Please use object option\n */\ntype DeprecatedOption = boolean\n\nexport const createContainer = <State, Update extends AnyFunction, Props>(\n  useValue: (props: Props) => readonly [State, Update],\n  options?: Options | DeprecatedOption,\n) => {\n  if (typeof options === 'boolean') {\n    // eslint-disable-next-line no-console\n    console.warn('boolean option is deprecated, please specify { concurrentMode: true }');\n    options = { concurrentMode: options };\n  }\n  const {\n    stateContextName = 'StateContainer',\n    updateContextName = 'UpdateContainer',\n    concurrentMode,\n  } = options || {};\n  const StateContext = createContext<State | null>(null);\n  const UpdateContext = createContextOrig<Update | null>(null);\n  StateContext.displayName = stateContextName;\n  UpdateContext.displayName = updateContextName;\n\n  const Provider: FC<Props> = (props) => {\n    const [state, update] = useValue(props);\n    return createElement(\n      UpdateContext.Provider,\n      { value: update },\n      createElement(StateContext.Provider, { value: state }, props.children),\n    );\n  };\n\n  const useSelector = <Selected>(\n    selector: (state: State) => Selected,\n  ) => {\n    if (\n      typeof process === 'object'\n      && process.env.NODE_ENV !== 'production'\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      && useContext(StateContext) === null\n    ) {\n      throw new Error('Please use <Provider>');\n    }\n    const selected = useContextSelector(StateContext as Context<State>, selector);\n    useDebugValue(selected);\n    return selected;\n  };\n\n  const useTrackedState = createTrackedSelector(useSelector);\n\n  const useUpdate = concurrentMode\n    ? () => {\n      if (\n        typeof process === 'object'\n        && process.env.NODE_ENV !== 'production'\n        && (\n          useContext(StateContext) === null\n          || useContextOrig(UpdateContext) === null\n        )\n      ) {\n        throw new Error('Please use <Provider>');\n      }\n      const contextUpdate = useContextUpdate(StateContext as Context<unknown>);\n      const update = useContextOrig(UpdateContext as ContextOrig<Update>);\n      return useCallback((...args: Parameters<Update>) => {\n        let result: ReturnType<Update> | undefined;\n        contextUpdate(() => {\n          result = update(...args);\n        });\n        return result as ReturnType<Update>;\n      }, [contextUpdate, update]);\n    }\n    // not concurrentMode\n    : () => {\n      if (\n        typeof process === 'object'\n        && process.env.NODE_ENV !== 'production'\n        && useContextOrig(UpdateContext) === null\n      ) {\n        throw new Error('Please use <Provider>');\n      }\n      return useContextOrig(UpdateContext as ContextOrig<Update>);\n    };\n\n  const useTracked = () => [useTrackedState(), useUpdate()] as [\n    ReturnType<typeof useTrackedState>,\n    ReturnType<typeof useUpdate>,\n  ];\n\n  return {\n    Provider,\n    useTrackedState,\n    useTracked,\n    useUpdate,\n    useSelector,\n  } as const;\n};\n","import { createElement, memo as reactMemo, forwardRef } from 'react';\nimport { trackMemo } from 'proxy-compare';\n\nimport type {\n  FC,\n  PropsWithChildren,\n  NamedExoticComponent,\n  ComponentType,\n  ComponentProps,\n  MemoExoticComponent,\n} from 'react';\n\nexport function memo<P extends Record<string, unknown>>(\n  Component: FC<P>,\n  propsAreEqual?: (\n    prevProps: Readonly<PropsWithChildren<P>>,\n    nextProps: Readonly<PropsWithChildren<P>>,\n  ) => boolean,\n): NamedExoticComponent<P>;\n\nexport function memo<T extends ComponentType<any>>(\n  Component: T,\n  propsAreEqual?: (\n    prevProps: Readonly<ComponentProps<T>>,\n    nextProps: Readonly<ComponentProps<T>>,\n  ) => boolean,\n): MemoExoticComponent<T>;\n\nexport function memo(Component: any, propsAreEqual?: any) {\n  const WrappedComponent = forwardRef((props: any, ref: any) => {\n    Object.values(props).forEach(trackMemo);\n    return createElement(Component, { ...props, ref });\n  });\n  return reactMemo(WrappedComponent, propsAreEqual);\n}\n"]},"metadata":{},"sourceType":"module"}